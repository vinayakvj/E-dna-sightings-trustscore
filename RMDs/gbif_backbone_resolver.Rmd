---
title: "GBIF Taxonomy"
author: "Nathan Reed (24110024)"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## GBIF Taxonomy

This R markdown file takes in a CSV file of eDNA samples and extracts all the unique species found in the "Species_In_LCA" column
It then identifies the taxonKey used for that species in GBIF along with other taxonomy data
This speeds up processing and minimises API calls by storing this information locally for each species
The resulting dataframe is then exported to "GBIF_Taxonomy.csv" which can then be imported and used in other scripts
If "GBIF_Taxonomy.csv" already exists in "../Data/" then it will only add new species which are in the imported datafile but not GBIF_Taxonomy.csv to minimise unnecessary processing


```{r}
library(dplyr)
library(stringr)
library(purrr)
library(readr)
library(tidyr)
library(rgbif)
library(progress)
library(tibble)
```


```{r}
# Function to deal with any empty fields returned by the API
`%||%` <- function(a, b) if (!is.null(a)) a else b

# Generate a list of unique species from the "Species_In_LCA" column
extract_unique_species <- function(df, col = "Species_In_LCA") {
  if (!col %in% names(df)) stop(sprintf('Column "%s" not found.', col))
  df[[col]] |>
    str_split(",") |>
    unlist(use.names = FALSE) |>
    str_squish() |>
    discard(~ .x == "" || is.na(.x)) |>
    unique() |>
    sort()
}

# Obtain the species taxonKey from GBIF
resolve_one <- function(name) {
  res <- tryCatch(
    rgbif::name_backbone(name = name, rank = "species"),
    error = function(e) list()
  )
  tibble(
    species_input = name,
    taxonKey      = res[["usageKey"]]       %||% NA_integer_,
    matchedName   = res[["scientificName"]] %||% NA_character_,
    matchType     = res[["matchType"]]      %||% NA_character_,
    matchRank     = res[["rank"]]           %||% NA_character_
  )
}

# Process all species and export to GBIF_Taxonomy.csv
resolve_species_backbone <- function(species_vec,
                                     out_csv = "GBIF_Taxonomy.csv",
                                     overwrite = FALSE,
                                     polite_pause = 0) {
  species_vec <- unique(str_squish(as.character(species_vec)))
  species_vec <- species_vec[species_vec != "" & !is.na(species_vec)]

  # Read existing lean file (if any) and normalize old schemas on the fly
  existing <- if (file.exists(out_csv) && !overwrite) read_csv(out_csv, show_col_types = FALSE) else NULL
  if (!is.null(existing)) {
    # keep only the lean columns if an older, wider file is present
    wanted <- c("species_input","taxonKey","matchedName","matchType","matchRank")
    missing <- setdiff(wanted, names(existing))
    if (length(missing)) {
      # try to fill matchRank from 'rank' if present (older schema)
      if ("rank" %in% names(existing) && "matchRank" %in% missing) existing <- rename(existing, matchRank = rank)
      # drop extras, keep available lean cols
      existing <- existing %>% select(any_of(wanted))
    }
  }

  to_resolve <- setdiff(species_vec, existing$species_input %||% character())

  if (length(to_resolve) == 0 && !is.null(existing)) {
    message("No new species to resolve. Using existing reference: ", out_csv)
    final <- existing %>%
      filter(species_input %in% species_vec) %>%
      distinct(species_input, .keep_all = TRUE) %>%
      arrange(species_input)
    write_csv(final, out_csv)
    return(final)
  }

  pb <- progress::progress_bar$new(
    total = length(to_resolve),
    format = "Resolving [:bar] :current/:total (:percent) ETA: :eta",
    clear = FALSE, width = 70
  )

  new_rows <- map_dfr(to_resolve, function(nm) {
    out <- resolve_one(nm)
    pb$tick()
    if (polite_pause > 0) Sys.sleep(polite_pause)
    out
  })

  final <- bind_rows(existing %||% tibble(), new_rows) %>%
    filter(species_input %in% species_vec) %>%
    distinct(species_input, .keep_all = TRUE) %>%
    arrange(species_input) %>%
    filter(matchRank %in% c("SPECIES", "GENUS")) # Important to filter only those where there is a species or genus match else it causes data download explosion later if it steps up to family level

  write_csv(final, out_csv)
  message("Wrote taxonomy reference: ", normalizePath(out_csv))
  final
}

# Run the script
df_in <- read_csv("../Data/data_with_genus_dna_pct.csv", show_col_types = FALSE)
df_in <- df_in %>% filter(class %in% c("Actinopterygii", "Chondrichthyes"))
species_vec <- extract_unique_species(df_in, "Species_In_LCA")
taxonomy <- resolve_species_backbone(
  species_vec,
  out_csv = "../Data/GBIF_Taxonomy.csv",   # adjust path if you like
  overwrite = FALSE,
  polite_pause = 0
)
```
